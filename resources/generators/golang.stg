declarefunctions(intf) ::=
<<
<intf.functions.values:{x | <intf.shortname><x.name>(*shim.ChaincodeStub, *<x.param>) <if(x.rettype)>(<x.rettype>, error)<else>error<endif> }; separator="\n">
>>

wrappersuffix(txn) ::=
<<
<if(txn)>Txn<else>Query<endif>Wrapper
>>

implementwrapper(txn, ns, func) ::=
<<

func (t *ShimHandler) <ns><func.name><wrappersuffix(txn)>(stub *shim.ChaincodeStub, _params []byte) ([]byte, error) {

     params := <func.param>{}
     err := proto.Unmarshal(_params, params)
     if (err != nil) {
        return nil, err
     }

     <if(x.rettype)>
     result, <endif>
     err := t.<if(txn)>transactions<else>queries<endif>.<ns><func.name>(stub, params)
     if (err != nil) {
        return nil, err
     }

     <if(x.rettype)>
     _result, err := proto.Marshal(result)
     if (err != nil) {
          return nil, err
     }
     return _result, nil
     <else>
     return nil, nil
     <endif>
}

>>

implementwrappers(txn, intf) ::=
<<
<intf.functions.values:{x | <implementwrapper(txn, intf.shortname, x)> }; separator="\n">
>>

dispatchfunction(txn, intf, func) ::=
<<
case intf == "<intf.name>" && function == <func.index>:
     return t.<intf.shortname><func.name><wrappersuffix(txn)>(stub, params)
>>

dispatchfunctions(txn, intf) ::=
<<
<intf.functions.values:{x | <dispatchfunction(txn, intf, x)> }; separator="\n">
>>

golang(transactions, queries) ::=
<<
/* Generated by obcc.  DO NOT EDIT */

package chaincode_support

import (
       	"errors"

	"github.com/golang/protobuf/proto"
	"github.com/openblockchain/obc-peer/openchain/chaincode/shim"
)

type Transactions interface {
     <transactions.values:{intf | <declarefunctions(intf)> }; separator="\n">
}

type Queries interface {
     <queries.values:{intf | <declarefunctions(intf)> }>
}

type ShimHandler struct {
     transactions Transactions
     queries      Queries
}

<transactions.values:{intf | <implementwrappers(true, intf)> }>
<queries.values:{intf | <implementwrappers(false, intf)> }>

// Run callback representing the invocation of a chaincode
func (t *ShimHandler) Run(stub *shim.ChaincodeStub, intf string, function int32, params []byte) ([]byte, error) {

	// Handle different functions
        switch {
        <transactions.values:{intf | <dispatchfunctions(true, intf)> }; separator="\n">
        }

	return nil, errors.New("Received unknown function invocation")
}

// Query callback representing the query of a chaincode
func (t *ShimHandler) Query(stub *shim.ChaincodeStub, intf string, function int32, params []byte) ([]byte, error) {

        switch {
        <queries.values:{intf | <dispatchfunctions(false, intf)> }; separator="\n">
        }
	return nil, errors.New("Invalid query")
}

func Start(transactions *Transactions, queries *Queries) error {
       err := shim.Start(&ShimHandler{transactions: transactions, queries: queries})
       if err != nil {
               return err
       }

       return nil
>>
