primary(provides) ::=
<<
<!
!-------------------------------------------------------------------------------------------------
! primary - main entry point for golang generator
!-------------------------------------------------------------------------------------------------
!
! This template is responsible for generating the primary golang shim that bridges between the
! Hyperledger fabric and chaincode.
!
!-------------------------------------------------------------------------------------------------
!>
/* Generated by chaintool.  DO NOT EDIT */

package ccs

import (
       	"errors"
        "regexp"
        "strconv"

	"github.com/hyperledger/fabric/core/chaincode/shim"
        "hyperledger/ccs/stub"
)

type Interfaces map[string]interface{}
type Dispatchers map[string]stub.Dispatcher

type ShimHandler struct {
     dispatchers Dispatchers
}

var txnre   = regexp.MustCompile("([a-zA-Z0-9.]*)/txn/([0-9]*)")
var queryre = regexp.MustCompile("([a-zA-Z0-9.]*)/query/([0-9]*)")

// Initialization function, called only once
func (t *ShimHandler) Init(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {

	if len(args) != 1 {
		return nil, errors.New("Expected exactly one argument")
	}

        if function != "init" {
               return nil, errors.New("Function must be \"init\"")
        }

        dispatcher, ok := t.dispatchers["appinit"]
        if !ok {
               return nil, errors.New("Interface not found")
        }
        
        return dispatcher.DispatchTxn(stub, 1, args[0])
}

// Callback representing the invocation of a chaincode
<implementhandler(true)>

// Callback representing the query of a chaincode
<implementhandler(false)>

func (t *ShimHandler) addDispatcher(name string, interfaces Interfaces) error {
     intf, ok := interfaces[name]
     if !ok {
             return errors.New("Interface not found")
     }

     dispatcher, err := stub.Create(name, intf)
     if err != nil {
            return err
     }

     t.dispatchers[name] = dispatcher
     return nil
}

func Start(interfaces Interfaces) error {

       handler := &ShimHandler{dispatchers: make(Dispatchers)}

       // Validate all of the interfaces
       <provides.values:{intf | <validateinterface(intf)> }; separator="\n">
       
       err := shim.Start(handler)
       if err != nil {
               return err
       }

       return nil
}
<!
!-------------------------------------------------------------------------------------------------
! end of primary template.
!-------------------------------------------------------------------------------------------------
!>
>>

stub() ::=
<<
<!
!-------------------------------------------------------------------------------------------------
! stub
!-------------------------------------------------------------------------------------------------
!
! This template defines things common to all server stubs
!
!-------------------------------------------------------------------------------------------------
!>
/* Generated by chaintool.  DO NOT EDIT */

package stub

import (
        "errors"
	"github.com/hyperledger/fabric/core/chaincode/shim"
)

type Dispatcher interface {
     DispatchTxn(stub *shim.ChaincodeStub, function int, params string) ([]byte, error)
     DispatchQuery(stub *shim.ChaincodeStub, function int, params string) ([]byte, error)
}

type Factory interface {
     Create(intf interface{}) (Dispatcher, error)
}

var factories = make(map[string]Factory)

func Register(name string, factory Factory) error {
     factories[name] = factory
     return nil
}

func Create(name string, intf interface{}) (Dispatcher, error) {
     factory, ok := factories[name]
     if !ok {
        return nil, errors.New("Factory not found")
     }

     return factory.Create(intf)
}
>>

server(intf) ::=
<<
<!
!-------------------------------------------------------------------------------------------------
! server
!-------------------------------------------------------------------------------------------------
!
! This template is responsible for generating the interface-specific golang provider shim
!
!-------------------------------------------------------------------------------------------------
!>
/* Generated by chaintool.  DO NOT EDIT */

package <intf.package>

import (
	proto "github.com/golang/protobuf/jsonpb"
	"github.com/hyperledger/fabric/core/chaincode/shim"
        "hyperledger/ccs/stub"
        "errors"
)

type CCInterface interface {
     <declarefunctions(intf, intf.transactions)>
     <declarefunctions(intf, intf.queries)>
}


type StubImpl struct {
     Interface CCInterface
}

// Factory mechanics
type FactoryImpl struct {
}

func init() {
     self := &FactoryImpl{}
     stub.Register("<intf.name>", self)
}

func (self *FactoryImpl) Create(intf interface{}) (stub.Dispatcher, error) {
     return &StubImpl{Interface: intf.(CCInterface)}, nil
}

func (self *StubImpl) DispatchTxn(stub *shim.ChaincodeStub, function int, params string) ([]byte, error) {
        // Handle different functions
        switch {
        <dispatchfunctions(true, intf, intf.transactions)>
        default:
                return nil, errors.New("Received unknown function invocation")
        }
}

func (self *StubImpl) DispatchQuery(stub *shim.ChaincodeStub, function int, params string) ([]byte, error) {
        // Handle different functions
        switch {
        <dispatchfunctions(true, intf, intf.queries)>
        default:
                return nil, errors.New("Received unknown function invocation")
        }
}

/* Server stubs */
<implementservers(intf, intf.transactions)>
<implementservers(intf, intf.queries)>

<!
!-------------------------------------------------------------------------------------------------
! end of server template.
!-------------------------------------------------------------------------------------------------
!>
>>

client(intf) ::=
<<
<!
!-------------------------------------------------------------------------------------------------
! client
!-------------------------------------------------------------------------------------------------
!
! This template is responsible for generating the interface-specific golang consumer shim
!
!-------------------------------------------------------------------------------------------------
!>
/* Generated by chaintool.  DO NOT EDIT */

package <intf.package>

import (
	proto "github.com/golang/protobuf/jsonpb"
	"github.com/hyperledger/fabric/core/chaincode/shim"
)

/* Client stubs */
<implementclients(true, intf, intf.transactions)>
<implementclients(false, intf, intf.queries)>

<!
!-------------------------------------------------------------------------------------------------
! end of client template.
!-------------------------------------------------------------------------------------------------
!>
>>

compositename(txn, intf, func)          ::= "\"<intf.name>/<if(txn)>txn<else>query<endif>/<func.index>\""
implementservers(intf, functions)  ::= "<functions.values:{x | <implementserver(intf, x)> }; separator=\"\n\">"
implementclients(txn, intf, functions)  ::= "<functions.values:{x | <implementclient(txn, intf, x)> }; separator=\"\n\">"
dispatchfunctions(txn, intf, functions) ::= "<functions.values:{x | <dispatchfunction(txn, intf, x)> }; separator=\"\n\">"

declarefunctions(intf, functions) ::=
<<
<functions.values:{x | <x.name>(*shim.ChaincodeStub, *<x.param>) <if(x.rettype)>(*<x.rettype>, error)<else>error<endif> }; separator="\n">
>>

dispatchfunction(txn, intf, func) ::=
<<
case function == <func.index>:
     return self.<func.name>Stub(stub, params)
>>

implementhandler(txn) ::=
<<
func (t *ShimHandler) <if(txn)>Invoke<else>Query<endif>(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {

	if len(args) != 1 {
		return nil, errors.New("Expected exactly one argument")
	}

        re := <if(txn)>txnre<else>queryre<endif>
        spec := re.FindAllStringSubmatch(function, -1)
        if spec == nil {
               return nil, errors.New("Could not parse function name")
        }

        dispatcher, ok := t.dispatchers[spec[0][1]]
        if !ok {
               return nil, errors.New("Interface not found")
        }

        index, err := strconv.Atoi(spec[0][2])
        if err == nil {
               return nil, errors.New("Could not convert function index")
        }

        return dispatcher.Dispatch<if(txn)>Txn<else>Query<endif>(stub, index, args[0])
}
>>

implementserver(intf, func) ::=
<<

func (self *StubImpl) <func.name>Stub(stub *shim.ChaincodeStub, _params string) ([]byte, error) {

     params := &<func.param>{}
     err := proto.UnmarshalString(_params, params)
     if (err != nil) {
        return nil, err
     }

     <if(func.rettype)>result, err := <else>err = <endif>self.Interface.<func.name>(stub, params)
     if (err != nil) {
        return nil, err
     }

     <if(func.rettype)>
     marshaler := &proto.Marshaler{}
     _result, err := marshaler.MarshalToString(result)
     if (err != nil) {
          return nil, err
     }
     return []byte(_result), nil
     <else>
     return nil, nil
     <endif>
}

>>

implementclient(txn, intf, func) ::=
<<

func <func.name>(stub *shim.ChaincodeStub, chaincodeName string, params *<func.param>) <\\>
<if(func.rettype)>(*<func.rettype>, error)<else>error<endif> {

     marshaler := &proto.Marshaler{}
     args := make([]string, 1)
     var err error

     args[0], err = marshaler.MarshalToString(params)
     if (err != nil) {
        return <if(func.rettype)>nil, <endif>err
     }

     <if(func.rettype)>_result, err :=<else>_, err =<endif> stub.<if(txn)>Invoke<else>Query<endif>Chaincode(chaincodeName, <compositename(txn, intf, func)>, args)

     <if(func.rettype)>
     result := &<func.rettype>{}
     err = proto.UnmarshalString(string(_result), result)
     if (err != nil) {
          return nil, err
     }
     return result, nil
     <else>
     return err
     <endif>
}

>>

validateinterface(intf) ::=
<<
if err := handler.addDispatcher("<intf.name>", interfaces); err != nil {
   return err
}
>>
