declarefunctions(intf, functions) ::=
<<
<functions.values:{x | <intf.ns><x.name>(*shim.ChaincodeStub, *<x.param>) <if(x.rettype)>(*<x.rettype>, error)<else>error<endif> }; separator="\n">
>>

wrappersuffix(txn) ::=
<<
<if(txn)>Txn<else>Query<endif>Wrapper
>>

implementwrapper(txn, ns, func) ::=
<<

func (t *ShimHandler) <ns><func.name><wrappersuffix(txn)>(stub *shim.ChaincodeStub, _params []byte) ([]byte, error) {

     params := &<func.param>{}
     err := proto.Unmarshal(_params, params)
     if (err != nil) {
        return nil, err
     }

     <if(func.rettype)>result, err := <else>err = <endif>t.<if(txn)>transactions<else>queries<endif>.<ns><func.name>(stub, params)
     if (err != nil) {
        return nil, err
     }

     <if(func.rettype)>
     _result, err := proto.Marshal(result)
     if (err != nil) {
          return nil, err
     }
     return _result, nil
     <else>
     return nil, nil
     <endif>
}

>>

implementwrappers(txn, intf, functions) ::=
<<
<functions.values:{x | <implementwrapper(txn, intf.ns, x)> }; separator="\n">
>>

implementclientstub(txn, intf, func) ::=
<<

func <intf.ns><func.name>(stub *shim.ChaincodeStub, chaincodeName string, params *<func.param>) <\\>
<if(func.rettype)>(*<func.rettype>, error)<else>error<endif> {

     _params, err := proto.Marshal(params)
     if (err != nil) {
        return <if(func.rettype)>nil, <endif>err
     }

     <if(func.rettype)>_result, err :=<else>_, err =<endif> stub.<if(txn)>Invoke<else>Query<endif>Chaincode(chaincodeName, "<intf.name>", <func.index>, _params)

     <if(func.rettype)>
     result := &<func.rettype>
     err = proto.Unmarshal(_result, result)
     if (err != nil) {
          return nil, err
     }
     return result, nil
     <else>
     return err
     <endif>
}

>>

implementclientstubs(txn, intf, functions) ::=
<<
<functions.values:{x | <implementclientstub(txn, intf, x)> }; separator="\n">
>>

dispatchfunction(txn, intf, func) ::=
<<
case intf == "<intf.name>" && function == <func.index>:
     return t.<intf.ns><func.name><wrappersuffix(txn)>(stub, params)
>>

dispatchfunctions(txn, intf, functions) ::=
<<
<functions.values:{x | <dispatchfunction(txn, intf, x)> }; separator="\n">
>>

golang(provides, consumes) ::=
<<
<!
!-------------------------------------------------------------------------------------------------
! golang - main entry point for golang generator
!-------------------------------------------------------------------------------------------------
!>
/* Generated by obcc.  DO NOT EDIT */

package chaincode_support

import (
       	"errors"

	"github.com/golang/protobuf/proto"
	"github.com/openblockchain/obc-peer/openchain/chaincode/shim"
)

type Transactions interface {
     <provides.values:{intf | <declarefunctions(intf, intf.transactions)> }; separator="\n">
}

type Queries interface {
     <provides.values:{intf | <declarefunctions(intf, intf.queries)> }; separator="\n">
}

type ShimHandler struct {
     transactions Transactions
     queries      Queries
}

<if(provides.values)>/* Server stubs */<endif>
<provides.values:{intf | <implementwrappers(true, intf, intf.transactions)> }>
<provides.values:{intf | <implementwrappers(false, intf, intf.queries)> }>

<if(consumes.values)>/* Client stubs */<endif>
<consumes.values:{intf | <implementclientstubs(true, intf, intf.transactions)> }>
<consumes.values:{intf | <implementclientstubs(false, intf, intf.queries)> }>

// Run callback representing the invocation of a chaincode
func (t *ShimHandler) Run(stub *shim.ChaincodeStub, intf string, function int32, params []byte) ([]byte, error) {

	// Handle different functions
        switch {
        <provides.values:{intf | <dispatchfunctions(true, intf, intf.transactions)> }; separator="\n">
        default:
                return nil, errors.New("Received unknown function invocation")
        }
}

// Query callback representing the query of a chaincode
func (t *ShimHandler) Query(stub *shim.ChaincodeStub, intf string, function int32, params []byte) ([]byte, error) {

        switch {
        <provides.values:{intf | <dispatchfunctions(false, intf, intf.queries)> }; separator="\n">
        default:
                return nil, errors.New("Invalid query")
        }
}

func Start(transactions Transactions, queries Queries) error {
       err := shim.Start(&ShimHandler{transactions: transactions, queries: queries})
       if err != nil {
               return err
       }

       return nil
}
>>
