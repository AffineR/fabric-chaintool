declarefunctions(intf) ::=
<<
<intf.functions.values:{x | <intf.shortname><x.name>(*shim.ChaincodeStub, *<x.param>) <if(x.rettype)>(<x.rettype>, error)<else>error<endif> }; separator="\n">
>>

implementwrapper(txn, ns, func) ::=
<<

func (t *ShimHandler) <ns><func.name><if(txn)>Txn<else>Query<endif>Wrapper(params []byte) ([]byte, error) {

     params := <func.param>{}
     err := proto.Unmarshal(_params, params)
     if (err != nil) {
        return nil, err
     }

     <if(x.rettype)>
     result, <endif>
     err = t.<if(txn)>transactions<else>queries<endif>.<ns><func.name>(stub, params)
     if (err != nil) {
        return nil, err
     }

     <if(x.rettype)>
     _result, err := proto.Marshal(result)
     if (err != nil) {
          return nil, err
     }
     return _result, nil
     <else>
     return nil, nil
     <endif>
}

>>

implementwrappers(txn, intf) ::=
<<
<intf.functions.values:{x | <implementwrapper(txn, intf.shortname, x)> }; separator="\n">
>>

golang(transactions, queries) ::=
<<
/* Generated by obcc.  DO NOT EDIT */

package chaincode_support

import (
       	"errors"

	"github.com/golang/protobuf/proto"
	"github.com/openblockchain/obc-peer/openchain/chaincode/shim"
)

type Transactions interface {
     <transactions.values:{intf | <declarefunctions(intf)> }; separator="\n">
}

type Queries interface {
     <queries.values:{intf | <declarefunctions(intf)> }>
}

type ShimHandler struct {
     transactions Transactions
     queries      Queries
}

<transactions.values:{intf | <implementwrappers(true, intf)> }>
<queries.values:{intf | <implementwrappers(false, intf)> }>

// Run callback representing the invocation of a chaincode
func (t *ShimHandler) Run(stub *shim.ChaincodeStub, intf string, function int32, params []byte) ([]byte, error) {

	// Handle different functions

	return nil, errors.New("Received unknown function invocation")
}

// Query callback representing the query of a chaincode
func (t *ShimHandler) Query(stub *shim.ChaincodeStub, intf string, function int32, params []byte) ([]byte, error) {

	return nil, errors.New("Invalid query")
}

>>
