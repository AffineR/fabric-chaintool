# com.obc.chaincode.golang Plaform
The canonical chaincode environment utilizes golang as its language.  This chapter documents how OBCC interfaces between the language neutral features (such as .cci interfaces), the OBC peer, and your application chaincode written in Go.
## Environment
Any invocation of 'obcc build*' will automatically manage the $GOPATH environment as an amalgam of the current environment variable and your chaincode project.  Your chaincode project need _not_ be visible within the current $GOPATH for your sources (or any of the compiler generated sources) to be included properly.  It will effectively include the following paths:
* $project-root/build/deps
  - Direct and transitive dependencies of your application as retrieved by _go get_.  This will likely be disabled during peer builds in the future, but it remains on by default for now for convenience while the libraries defined as part of the platform are ironed out.
* $project-root/build
  - Default location for compiler generated artifacts
* $project-root
  - Location for your project files, typically under $project-root/src/chaincode
* current $GOPATH as set in the environment

## Chaincode Integration
### Entry-point
Your chaincode entry-point _func main()_ is placed in the package "chaincode" under $project-root/src/chaincode.   Other packages may be placed in other locations and imported by your entry-point module using standard golang mechanisms, typically somewhere under $project-root/src.  Any files that are under $project-root/src will be included in the final CCA package.
### Imports
Chaincode applications will want to import from 4 primary areas in addition to any needed for the application logic:
* openblockchain/ccs - chaincode support
  - general generated shim logic output by the compiler
* openblockchain/cci - chaincode interface
  - each declared interface is placed under a golang package based on the name of the .cci file.  For instance "com.foo.bar.cci" is placed in the package "bar" under the path $GOPATH/src/openblockchain/cci/com/foo/bar
* github.com/golang/protobuf/proto - google protocol buffer support
  - needed to encode/decode PB objects generated by the shim layers
* github.com/openblockchain/obc-peer/openchain/chaincode/shim - pulls in general OBC chaincode support

For example:
```
import (
	"openblockchain/ccs"
	"openblockchain/cci/project"
	"openblockchain/cci/com/obc/chaincode/example02"

	"github.com/golang/protobuf/proto"
	"github.com/openblockchain/obc-peer/openchain/chaincode/shim"
)
```
### Hooks and Registration
Each chaincode application is responsible for calling ccs.Start() to register itself as chaincode with the peer.  ccs.Start() takes a pointer to a ccs.ShimHandler{} structure.  This structure is generated by the compiler and placed within $project-root/build/src/openblockchain/ccs/shim.go as an aggregate of all of the CCI interfaces declared as _provided_.  It is the callers responsibility to provide a pointer to each interface declared.  It is idiomatic to create one interface (e.g. "ChaincodeExample", as per below) to handle all interfaces.  However, for special circumstances such as function-name collisions, the caller may wish to dispatch certain interfaces to different handlers.
```
type ChaincodeExample struct {
}

...

func main() {
	self := &ChaincodeExample{}
	handler := ccs.ShimHandler{Project: self, Example02: self}
	err := ccs.Start(&handler) // Our one instance implements both Transactions and Queries interfaces
	if err != nil {
		fmt.Printf("Error starting example chaincode: %s", err)
	}
}
```

### Callbacks
Every _provided_ interface requires an implementation for any _transactions_ or _queries_.  There is generally a 1:1 mapping between the CCI declaration and the required function signature in your code.  For instance, the following CCI declaration:
```
queries {
        BalanceResult CheckBalance(Entity) = 1;
}
```
requires a function signature that looks like:
```
func (t *ChaincodeExample) CheckBalance(stub *shim.ChaincodeStub, param *example02.Entity) (*example02.BalanceResult, error) {}
```
Most notably, every callback always takes a shim.ChaincodeStub pointer as its first parameter, followed by an input parameter and return parameter as declared in the interface definition.  Functions that return _void_ simply return a single _error_ rather than _(type, error)_.
## Generated Code Structure
### Overview
All generated code is placed under $project-root/build, which as mentioned earlier is implicitly included in the $GOPATH.  Interfaces are emitted to build/src/openblockchain/cci, and general chaincode support shims are emitted to build/src/openblockchain/ccs.
```
build/src/
└── openblockchain
    ├── cci
    │   ├── com
    │   │   └── obc
    │   │       └── chaincode
    │   │           └── example02
    │   │               ├── interface.pb.go
    │   │               ├── interface.proto
    │   │               └── server-shim.go
    │   └── project
    │       ├── interface.pb.go
    │       ├── interface.proto
    │       └── server-shim.go
    └── ccs
        └── shim.go
```
### Interfaces
Interfaces consist of 4 major artifact types per declared interface:
* interface.proto - The google protobuf definition derived from the corresponding .cci definition.
* interface.pb.go - The compiled protobuf definition, as emitted by _protoc --go_out_.
* server-shim.go - The server-side shim for a provided interface.
* client-shim.go - The client-side shim for a consumed interface.

### Shims
